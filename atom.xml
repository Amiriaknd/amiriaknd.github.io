<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lord Camelot</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-22T08:51:31.113Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Amiria</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript 笔记</title>
    <link href="http://yoursite.com/2017/10/07/2017-10-07/"/>
    <id>http://yoursite.com/2017/10/07/2017-10-07/</id>
    <published>2017-10-06T16:00:00.000Z</published>
    <updated>2017-10-22T08:51:31.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object-assgin"><a href="#Object-assgin" class="headerlink" title="Object.assgin()"></a>Object.assgin()</h3><p><code>Object.assign(target, ...source)</code><br>接受一个目标对象和若干个源对象，返回修改过的目标对象<br>会将源对象的<strong>自身</strong>的<strong>可枚举</strong>的属性复制到目标对象中，相同的属性会被覆盖，后面的会覆盖前面的。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(</div><div class="line"> &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;,</div><div class="line">     bar: &#123;</div><div class="line">          value: <span class="number">2</span></div><div class="line">     &#125;,</div><div class="line">     baz: &#123;</div><div class="line">          value: <span class="number">3</span>,</div><div class="line">          enumerable: <span class="literal">true</span></div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>变异方法，会修改<code>target</code><br>复制的过程中会调用<code>source</code>的<code>getter</code>和<code>target</code>的<code>setter</code>，因此assign并不是一个属性的完全拷贝，而是一个值的重新分配。</p><p>assign是浅拷贝，对于引用对象也只拷贝其引用值<br>如果source的属性和target的只读属性重名，就会抛出<code>TypeError</code><br>会跳过<code>null</code>或<code>undefined</code>的源对象</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>js是一个编译语言<br>通常来说编译有三个部分<br><code>分词/词法分析（tokenizing/lexing）</code>会将字符串分解为有意义的<code>词法单元（token）</code>。<br><code>tokenizing</code>和<code>lexing</code>的区别在于，lexing进行判断a是一个独立的token还是其他token的一部分的时候，会调用有状态的解析规则</p><p><code>解析/语法分析（parsing）</code>会将token流转换为由元素逐级嵌套的代表程序语法结构的树，即<code>抽象语法树（Abstract Syntax Tree, AST）</code></p><p><code>代码生成</code>  将AST转换为可执行代码</p><h3 id="LHS-RHS-声明提前"><a href="#LHS-RHS-声明提前" class="headerlink" title="LHS  RHS  声明提前"></a>LHS  RHS  声明提前</h3><p>引擎执行编译的时候，需要借助编译器和作用域</p><p>变量进行赋值（<code>var a = 2</code>）的时候，编译器会先在当前作用域中声明一个变量(<code>var a</code>)，然后引擎运行的时候会在作用域中查找这个变量，如果能够找到的话就会对它进行赋值。(<code>a = 2</code>)</p><p>引擎查找变量的时候，根据变量的位置，分为<code>LHS</code>和<code>RHS</code>两种查找类型<br><code>LHS</code>发生在如<code>a = 2</code>这种情况下，引擎找的是变量a的容器（地址），方便对它进行赋值操作<br><code>RHS</code>发生在如<code>a()</code>这种情况下，引擎找的是变量a的值，来使用这个值<br>因此形如<code>b = a</code>这种，对b进行查找的LHS，对a进行查找的是RHS</p><p>特别的，<code>function foo(a) {...}</code>这种函数声明，和<code>var foo; foo = function(a){...}</code> 这种在查找上有细微区别。<br>编译器在生成代码的时候会同时处理前者的声明和值的定义。而后者只会声明foo，引擎执行到这里的时候还是会进行RHS查找</p><p>这就是所说的“函数声明会将整个赋值语句提前“<br>并不是真的把声明提到了作用域的最前面，而是在编译器进行编译的时候就已经在当前作用域中执行了声明操作。</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>在进行RHS查找的时候，如果所有作用域都找不到这个变量，就会抛出<code>ReferenceError</code><br>而LHS查找的时候，如果找不到这个变量，在非严格模式下会在全局作用域创建这么一个变量并返回给引擎，严格模式下一样会抛出<code>ReferenceError</code></p><p>如果RHS查找到一个变量之后，对它进行了不合理的操作，如对一个非函数类型的值进行函数调用或引用<code>null</code>、<code>undefined</code>的属性，就会抛出<code>TypeError</code></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>无论函数在哪里被调用，也无论如何被调用，它的词法作用域都<strong>只</strong>由函数<strong>声明</strong>时所处的位置决定。（闭包）</p><p>词法作用域查找的时候只会查找<strong>一级标识符</strong>。<br>比如如果要查找<code>a.b.c</code>，那么词法作用域只会查找到a，找到变量a之后，对象属性访问规则会接管对b和c的访问。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Object-assgin&quot;&gt;&lt;a href=&quot;#Object-assgin&quot; class=&quot;headerlink&quot; title=&quot;Object.assgin()&quot;&gt;&lt;/a&gt;Object.assgin()&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Object.assign(target, ...source)&lt;/code&gt;&lt;br&gt;接受一个目标对象和若干个源对象，返回修改过的目标对象&lt;br&gt;会将源对象的&lt;strong&gt;自身&lt;/strong&gt;的&lt;strong&gt;可枚举&lt;/strong&gt;的属性复制到目标对象中，相同的属性会被覆盖，后面的会覆盖前面的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记 javascript" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0-javascript/"/>
    
  </entry>
  
  <entry>
    <title>centos6 安装 python3.6.2、pip、virtualenv</title>
    <link href="http://yoursite.com/2017/09/19/2017-09-19/"/>
    <id>http://yoursite.com/2017/09/19/2017-09-19/</id>
    <published>2017-09-18T16:00:00.000Z</published>
    <updated>2017-10-22T08:51:15.025Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-准备"><a href="#1-准备" class="headerlink" title="1.　准备"></a>1.　准备</h3><p>创建一个目录来放置下载的源码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir python-source</div><div class="line">$ <span class="built_in">cd</span> python-source</div></pre></td></tr></table></figure></p><a id="more"></a><p>下载python源文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget --no-check-certificate https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgz</div></pre></td></tr></table></figure></p><p>解压<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ tar -xzvf Python-3.6.2.tgz</div><div class="line">$ <span class="built_in">cd</span> Python-3.6.2</div></pre></td></tr></table></figure></p><p>在<code>/usr/local</code>下创建安装目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo mkdir /usr/<span class="built_in">local</span>/python3</div></pre></td></tr></table></figure></p><h3 id="2-编译安装"><a href="#2-编译安装" class="headerlink" title="2. 编译安装"></a>2. 编译安装</h3><p>指定创建的目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ./configure --prefix=/usr/<span class="built_in">local</span>/python3</div></pre></td></tr></table></figure></p><p>我的原生centos环境有报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">no acceptable C compiler found <span class="keyword">in</span> <span class="variable">$PATH</span></div></pre></td></tr></table></figure></p><p>只要安装gcc编译器就行了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install gcc</div><div class="line">$ sudo ./configure --prefix=/usr/<span class="built_in">local</span>/python3</div></pre></td></tr></table></figure></p><p>开始编译<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo make</div></pre></td></tr></table></figure></p><p>我在安装的时候提示缺少依赖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Python build finished successfully!</div><div class="line">The necessary bits to build these optional modules were not found:</div><div class="line">_bz2 _curses _curses_panel</div><div class="line">_dbm _gdbm _lzma</div><div class="line">_sqlite3 _ssl _tkinter</div><div class="line">readline zlib</div><div class="line">To find the necessary bits, look <span class="keyword">in</span> setup.py <span class="keyword">in</span> detect_modules() <span class="keyword">for</span> the module<span class="string">'s name.</span></div></pre></td></tr></table></figure></p><p>需要下载这些依赖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install bzip2-devel curses-devel dbm-devel gdbm-devel xz-devel sqlite sqlite-devel openssl openssl-devel tkinter tcl-devel tk-devel readline readline-devel zlib zlib-devel</div></pre></td></tr></table></figure></p><p>重新编译<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo make clean</div><div class="line">$ sudo make</div></pre></td></tr></table></figure></p><p>这次没有再报错，安装就可以了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo make install</div></pre></td></tr></table></figure></p><h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h3><p>自己编译源码安装并不会自动创建软链接，需要手动创建</p><h4 id="3-1-不改变自带的python2的软链接"><a href="#3-1-不改变自带的python2的软链接" class="headerlink" title="3.1 不改变自带的python2的软链接"></a>3.1 不改变自带的python2的软链接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/bin/python3</div></pre></td></tr></table></figure><p>使用python使用自带的python2.6，python3使用python3.6</p><h4 id="3-2-修改默认的python链接"><a href="#3-2-修改默认的python链接" class="headerlink" title="3.2 修改默认的python链接"></a>3.2 修改默认的python链接</h4><p>首先备份一下原本的python<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo mv python python2.6</div><div class="line">$ sudo vi /usr/bin/yum</div></pre></td></tr></table></figure></p><p>将第一行的<code>#!/usr/bin/python</code>改为<code>#!/usr/bin/python2.6</code><br>然后<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/python3/bin/python3 /usr/bin/python</div></pre></td></tr></table></figure></p><p>python命令可以直接使用python3.6，python2.6来使用python2.6</p><p>其实不是很建议修改默认的python链接，可能会导致各种奇怪的问题</p><h4 id="3-3-为pip创建软链接"><a href="#3-3-为pip创建软链接" class="headerlink" title="3.3 为pip创建软链接"></a>3.3 为pip创建软链接</h4><p>如果按照上面的步骤来，有完整的安装好依赖，那么编译安装的python默认有安装pip的，只是需要手动创建一个软链接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/python3/bin/pip3 /usr/bin/pip</div></pre></td></tr></table></figure></p><p>$$$$ 4. 安装virtualenv<br>直接使用pip安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install virtualenv</div></pre></td></tr></table></figure></p><p>但是奇怪的是，虽然virtualenv安装成功了，但是直接使用<code>virtualenv</code>指令却提示<code>command not found</code><br>所以需要手动创建软链<br>跟上面一样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ln -s /usr/<span class="built_in">local</span>/python3/bin/virtualenv /usr/<span class="built_in">local</span>/bin/virtualenv</div></pre></td></tr></table></figure></p><p>就可以了</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-准备&quot;&gt;&lt;a href=&quot;#1-准备&quot; class=&quot;headerlink&quot; title=&quot;1.　准备&quot;&gt;&lt;/a&gt;1.　准备&lt;/h3&gt;&lt;p&gt;创建一个目录来放置下载的源码&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ mkdir python-source&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; python-source&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="配置 python linux" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE-python-linux/"/>
    
  </entry>
  
  <entry>
    <title>移动端问题整理</title>
    <link href="http://yoursite.com/2017/07/24/2017-07-24/"/>
    <id>http://yoursite.com/2017/07/24/2017-07-24/</id>
    <published>2017-07-23T16:00:00.000Z</published>
    <updated>2017-10-22T08:50:57.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软键盘破坏定位"><a href="#软键盘破坏定位" class="headerlink" title="软键盘破坏定位"></a>软键盘破坏定位</h3><p>在有标签的页面使用<code>position: fixed</code>的时候，会有奇怪的问题<br>比如ios上点击input获取软键盘时，fixed会暂时失效变成类似absolute的定位，在含有滚动的页面fixed会和其他节点一起滚动。</p><a id="more"></a><p>解决方法是保证fixed的父节点不可滚动<br>但是还是会有其他问题，比如安卓软键盘唤起后遮挡住input标签之类的。所以尽量用<code>position: absolute</code>或者<code>display: flex</code>代替<code>position: fixed</code></p><h3 id="移动端自适应"><a href="#移动端自适应" class="headerlink" title="移动端自适应"></a>移动端自适应</h3><p><a href="https://github.com/amfe/article/issues/17" target="_blank" rel="external">https://github.com/amfe/article/issues/17</a><br><strong>设备像素比</strong><br>首先像素这个词分为有设备的物理像素和独立于设备之外的虚拟像素（如css像素）<br>根据不同的设备，虚拟像素也会对应不同的物理像素<br>dpr就是物理像素和虚拟像素的比值<br>即<br>设备像素比（device pixel ratio） = 物理像素 / 设备独立像素</p><p>这个lib主要是根据不同的设备，动态的改写<code>meta</code>标签和html的<code>font-size</code>值，并给html加<code>data-dpr</code>属性<br>它会把视觉稿分为100份，每一份为一个单位<code>a</code>，10a = 1rem<br>也就是说，对于750px的视觉稿，每个a是7.5px，也就是说1rem=75px</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;软键盘破坏定位&quot;&gt;&lt;a href=&quot;#软键盘破坏定位&quot; class=&quot;headerlink&quot; title=&quot;软键盘破坏定位&quot;&gt;&lt;/a&gt;软键盘破坏定位&lt;/h3&gt;&lt;p&gt;在有标签的页面使用&lt;code&gt;position: fixed&lt;/code&gt;的时候，会有奇怪的问题&lt;br&gt;比如ios上点击input获取软键盘时，fixed会暂时失效变成类似absolute的定位，在含有滚动的页面fixed会和其他节点一起滚动。&lt;/p&gt;
    
    </summary>
    
    
      <category term="移动端 笔记" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSS笔记整理</title>
    <link href="http://yoursite.com/2017/07/17/2017-07-17/"/>
    <id>http://yoursite.com/2017/07/17/2017-07-17/</id>
    <published>2017-07-16T16:00:00.000Z</published>
    <updated>2017-10-22T08:50:43.613Z</updated>
    
    <content type="html"><![CDATA[<h4 id="width-100-和-width-auto"><a href="#width-100-和-width-auto" class="headerlink" title="width: 100% 和 width: auto"></a>width: 100% 和 width: auto</h4><p><code>width: 100%</code>使得内容区为父元素100%的宽度，当存在padding或者margin的时候，元素会跑到父元素外面<br>而<code>width: auto</code>会使内容区宽度自适应，元素盒模型总是占据父元素的整行。(外边距+边框+内边距+内容区=父元素的宽度）</p><a id="more"></a><p><img src="1-1.png" alt="@父元素： width 1000px" title="父元素： width 1000px"><br><img src="1-2.png" alt="@width: 100%" title="width: 100%"><br><img src="1-3.png" alt="@width: auto" title="width: auto"><br><img src="1-4.png" alt="@width: auto; padding: 0;" title="width: auto; padding: 0;"></p><hr><h4 id="word-wrap-和-word-break"><a href="#word-wrap-和-word-break" class="headerlink" title="word-wrap 和 word-break"></a>word-wrap 和 word-break</h4><p>通常来说，如果什么设置都没有，当遇到一个特别长的单词的时候，如果前面有其他文本，浏览器会尝试将单词移到下一行。<br>如果下一行也塞不下，就会溢出父元素<br><img src="2-1.png" alt="@word-wrap: normal;  word-break: keep-all;" title="word-wrap: normal;  word-break: keep-all;"></p><p>而如果设置了<code>word-wrap: break-word;</code>当单词移到下一行还是放不下时，就会将单词在打断在下一行<br><img src="2-2.png" alt="@word-wrap: break-word; word-break: keep-all;" title="word-wrap: break-word; word-break: keep-all;"></p><p>但是这样的话上一行的空间就被浪费了，所以就有<code>word-break: break-all;</code>所有的单词都会在行尾被打断<br><img src="2-3.png" alt="@word-wrap: break-word; word-break: break-all;" title="word-wrap: break-word; word-break: break-all;"></p><blockquote><p>break-all会使得单词难以辨认</p></blockquote><p><code>word-wrap: normal; word-break: break-all;</code>和<code>word-wrap: word-break;</code>的效果看起来是一样的<br>因为<code>word-break: break-all</code>一旦设置，就不会在发生由于当前行不够位置要移到下一行再判断是否要断词这种情况了。</p><blockquote><p>在只有<code>word-wrap</code>而没有<code>word-break</code>的时候，如果设置<code>display: box</code>。会使得<code>word-wrap</code>失效</p></blockquote><hr><h4 id="text-overflow-clip-ellipsis"><a href="#text-overflow-clip-ellipsis" class="headerlink" title="text-overflow: clip | ellipsis"></a>text-overflow: clip | ellipsis</h4><p>这个属性会使得元素在将要溢出其块元素的时候将其阶段或者显示…<br>依赖于<code>width</code>和<code>overflow</code>属性，元素必须定义这两个属性，其中<code>overflow</code>不能为<code>visible</code><br><img src="3-1.png" alt="Alt text"></p><hr><h4 id="line-clamp-Number"><a href="#line-clamp-Number" class="headerlink" title="line-clamp: Number"></a>line-clamp: Number</h4><p>可以限制块元素显示的文本的行数<br>必须依赖<code>display: -webkit-box;</code> <code>-webkit-box-orient;</code>   <code>text-overflow</code>三个属性<br>值为要显示的文本的行数<br><img src="4-1.png" alt="@line-clamp: 2" title="line-clamp: 2"><br>这个属性支持不是很完善，不在CSS规范草案中，慎用</p><hr><h4 id="outline"><a href="#outline" class="headerlink" title="outline"></a>outline</h4><p>对象的轮廓，画在<code>border</code>的外面<br>不同于<code>border</code>，它不会占据布局空间，也不会影响到元素的尺寸<br><img src="5-1.png" alt="Alt text"></p><hr><h4 id="height-100-和height-auto"><a href="#height-100-和height-auto" class="headerlink" title="height: 100%和height: auto"></a>height: 100%和height: auto</h4><p><code>height: 100%</code>意味着元素会占据父元素的100%的高度<br>而<code>height: auto</code>则是自适应的，它的高度取决于它的所有子元素的高度<br><a href="https://stackoverflow.com/questions/15943009/difference-between-css-height-100-vs-height-auto" target="_blank" rel="external">https://stackoverflow.com/questions/15943009/difference-between-css-height-100-vs-height-auto</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;width-100-和-width-auto&quot;&gt;&lt;a href=&quot;#width-100-和-width-auto&quot; class=&quot;headerlink&quot; title=&quot;width: 100% 和 width: auto&quot;&gt;&lt;/a&gt;width: 100% 和 width: auto&lt;/h4&gt;&lt;p&gt;&lt;code&gt;width: 100%&lt;/code&gt;使得内容区为父元素100%的宽度，当存在padding或者margin的时候，元素会跑到父元素外面&lt;br&gt;而&lt;code&gt;width: auto&lt;/code&gt;会使内容区宽度自适应，元素盒模型总是占据父元素的整行。(外边距+边框+内边距+内容区=父元素的宽度）&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记 css" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0-css/"/>
    
  </entry>
  
  <entry>
    <title>Javascript 笔记 --- 上传</title>
    <link href="http://yoursite.com/2017/07/06/2017-07-06/"/>
    <id>http://yoursite.com/2017/07/06/2017-07-06/</id>
    <published>2017-07-05T16:00:00.000Z</published>
    <updated>2017-10-22T08:50:24.973Z</updated>
    
    <content type="html"><![CDATA[<h4 id="lt-input-type-quot-file-quot-gt"><a href="#lt-input-type-quot-file-quot-gt" class="headerlink" title="&lt;input type=&quot;file&quot;&gt;"></a><code>&lt;input type=&quot;file&quot;&gt;</code></h4><p><strong>属性<code>accept=&quot;&quot;</code></strong><br>accept只是为上传文件的类型提供一个默认的搜索过滤，而不会强制要求必须上传这种类型的文件，可以上传任意的文件且浏览器都会接受</p><a id="more"></a><p>设置<code>accept=&quot;video/*&quot;</code>，在上传文件的时候选择“全部文件”。<br>上传一个jpg文件：<br><img src="1-1.png" alt="Alt text"></p><p>上传一个exe文件：<br><img src="1-2.png" alt="Alt text"></p><p>甚至可以上传一个随便起的后缀文件：<br><img src="1-3.png" alt="Alt text"></p><p>可见当浏览器上传以后，浏览器会自动确定文件的类型，与accept规定的类型无关</p><p>accept的值可以是以下：</p><ul><li><code>file_extension</code>  文件扩展名，如<code>.gif</code>, <code>.jpg</code>, <code>.png</code>。<blockquote><p>值得一提的是，如果留空，则上传文件的窗口默认为全部文件。<br>如果是自定义的后缀如.asd文件，默认过滤出ASD文件<br>如果定义多个文件，如”.jpg, .png”，上传文件的窗口显示“自定义文件”，但过滤规则一样有效，会过滤出所有的jpg和png文件</p></blockquote></li></ul><ul><li><code>audio/*</code>  音频文件</li><li><code>video/*</code>  视频文件</li><li><code>image/*</code>  图像文件</li><li><code>media_type</code> <a href="http://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank" rel="external">http://www.iana.org/assignments/media-types/media-types.xhtml</a></li></ul><hr><p><strong>属性multiple</strong></p><p><code>multiple=&quot;multiple&quot;</code><br>默认情况下文件只能选一个，设置multiple之后可以选择多个文件</p><h4 id="FORMDATA"><a href="#FORMDATA" class="headerlink" title="FORMDATA"></a>FORMDATA</h4><p><code>formdata</code>是可以独立于表单之外的表单数据，可以用来上传二进制文件</p><p>使用<code>new FormData()</code>来创建一个formdata对象，然后使用<code>append(name, value, filename)</code>来添加字段。</p><p><code>value</code>可以是<code>blob</code>对象、<code>file</code>对象或者字符串。<br>如果value既不是blob对象，也不是file对象的话，它就会被转换为字符串</p><p><code>filename</code>是可选的，如果value是blob或file，会被当作文件名来发送到服务器上</p><p>formdata无法直接通过<code>console.log()</code>来打印，要想监视formdata的数据，需要使用<code>for(let pair of formdata.entries())</code>，<code>pair</code>是一个数组，<code>0</code>是<code>value</code>，<code>1</code>是<code>file</code></p><blockquote><p><code>Blob</code>对象表示不可变的类似文件对象的原始数据。Blob表示不一定是JavaScript原生形式的数据。 File 接口基于Blob，继承了 blob的功能并将其扩展使其支持用户系统上的文件。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;lt-input-type-quot-file-quot-gt&quot;&gt;&lt;a href=&quot;#lt-input-type-quot-file-quot-gt&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt;input type=&amp;quot;file&amp;quot;&amp;gt;&quot;&gt;&lt;/a&gt;&lt;code&gt;&amp;lt;input type=&amp;quot;file&amp;quot;&amp;gt;&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;属性&lt;code&gt;accept=&amp;quot;&amp;quot;&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;accept只是为上传文件的类型提供一个默认的搜索过滤，而不会强制要求必须上传这种类型的文件，可以上传任意的文件且浏览器都会接受&lt;/p&gt;
    
    </summary>
    
    
      <category term="笔记 javascript" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0-javascript/"/>
    
  </entry>
  
  <entry>
    <title>HTML-Parser 2</title>
    <link href="http://yoursite.com/2017/06/14/2017-06-14/"/>
    <id>http://yoursite.com/2017/06/14/2017-06-14/</id>
    <published>2017-06-13T16:00:00.000Z</published>
    <updated>2017-10-22T08:50:06.558Z</updated>
    
    <content type="html"><![CDATA[<p>根据上一篇文章，结合Vue源码，尝试进行一个简单的HTML-Parser实现</p><a id="more"></a><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>根据<a href="https://www.w3.org/TR/html51/syntax.html" target="_blank" rel="external">W3C的文档</a></p><blockquote><p>Attributes have a name and a value. Attribute names must consist of one or more characters other than the space characters, U+0000 NULL, U+0022 QUOTATION MARK (“), U+0027 APOSTROPHE (‘), U+003E GREATER-THAN SIGN (&gt;), U+002F SOLIDUS (/), and U+003D EQUALS SIGN (=) characters, the control characters, and any characters that are not defined by Unicode. </p></blockquote><p>可知属性名的模式<code>[^\s&quot;&#39;&gt;\/=]</code>，同时不能为<code>null</code>，所以得到<code>/[^\s&quot;&#39;&gt;\/=]+/</code></p><hr><p>值可以分为四种：</p><h5 id="1-Empty-attribute-syntax"><a href="#1-Empty-attribute-syntax" class="headerlink" title="1.Empty attribute syntax"></a>1.Empty attribute syntax</h5><blockquote><p>If an attribute using the empty attribute syntax is to be followed by another attribute, then there must be a space character separating the two.</p></blockquote><p>因此整个的属性模式需要以至少一个空白字符开头</p><h5 id="2-Unquoted-attribute-value-syntax"><a href="#2-Unquoted-attribute-value-syntax" class="headerlink" title="2.Unquoted attribute value syntax"></a>2.Unquoted attribute value syntax</h5><blockquote><p>The attribute name, followed by zero or more space characters, followed by a single U+003D EQUALS SIGN character, followed by zero or more space characters, followed by the attribute value</p></blockquote><p>这段话可以得出<code>\s*=\s*</code></p><blockquote><p>attribute value, which, in addition to the requirements given above for attribute values, must not contain any literal space characters, any U+0022 QUOTATION MARK characters (“), U+0027 APOSTROPHE characters (‘), U+003D EQUALS SIGN characters (=), U+003C LESS-THAN SIGN characters (&lt;), U+003E GREATER-THAN SIGN characters (&gt;), or U+0060 GRAVE ACCENT characters (`), and must not be the empty string.</p></blockquote><p>可得<code>[^\s&quot;&#39;=&lt;&gt;</code>]+<code>即没有引号的情况下，值的模式是</code>/\s<em>=\s</em>[^\s”‘=&lt;&gt;<code>]+/</code></p><h5 id="3-Single-quoted-attribute-value-syntax"><a href="#3-Single-quoted-attribute-value-syntax" class="headerlink" title="3.Single-quoted attribute value syntax"></a>3.Single-quoted attribute value syntax</h5><blockquote><p>The attribute name, followed by zero or more space characters, followed by a single U+003D EQUALS SIGN character, followed by zero or more space characters, followed by a single U+0027 APOSTROPHE character (‘), followed by the attribute value, which, in addition to the requirements given above for attribute values, must not contain any literal U+0027 APOSTROPHE characters (‘), and finally followed by a second single U+0027 APOSTROPHE character (‘).</p></blockquote><p>可得<code>/\s*=\s*&#39;[^&#39;]*&#39;/</code></p><h5 id="4-Double-quoted-attribute-value-syntax"><a href="#4-Double-quoted-attribute-value-syntax" class="headerlink" title="4.Double-quoted attribute value syntax"></a>4.Double-quoted attribute value syntax</h5><blockquote><p>The attribute name, followed by zero or more space characters, followed by a single U+003D EQUALS SIGN character, followed by zero or more space characters, followed by a single U+0022 QUOTATION MARK character (“), followed by the attribute value, which, in addition to the requirements given above for attribute values, must not contain any literal U+0022 QUOTATION MARK characters (“), and finally followed by a second single U+0022 QUOTATION MARK character (“).</p></blockquote><p>和第三种情况差不多，即<code>/\s*=\s*&quot;[^&quot;]*&quot;/</code></p><p>综合一下，可以发现空值对值的模式没有要求，只要在整个属性的前面加上空白字符就可以了。其他三个模式等号部分是一样的，只有后面的不同<br>因此可以得出值的模式/\s<em>=\s</em>(“[^”]<em>“|’[^’]</em>‘|[^\s”‘=&lt;&gt;`]+)/，然而由于有空值的存在，因此这个模式应当是可选的</p><hr><p>对比一下vue的属性匹配模式/^\s<em>([^\s”‘&lt;&gt;\/=]+)(?:\s</em>((?:=))\s<em>( ?:”([^”]</em>)”+|’([^’]*)’+|([^\s”‘=&lt;&gt;`]+) )?/</p><p>vue一开始的\s是*而非+，不是很理解<br>关于属性名的判断vue加上了对&lt;的限制，考虑的更加全面<br>还有双引号和单引号的情况vue加上了+修饰，感觉不是很有必要？如果是引号属性的话必定有而且只有一对存在吧<br>同时为了方便分析，为需要的内容加上括号来捕获它们</p><p>最终定下来属性模式为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> attrRe = <span class="regexp">/^\s+([^\s"'&lt;&gt;\/=]+)(\s*=\s*(("([^"]*)")|('([^']*)')|[^\s"'=&lt;&gt;`]+))?/g</span></div></pre></td></tr></table></figure></p><h4 id="开标签"><a href="#开标签" class="headerlink" title="开标签"></a>开标签</h4><p>接下来是开标签，既然已经有了属性，那么开标签就很容易分析了</p><blockquote><p>Start tags must have the following format:</p><pre><code>1. The first character of a start tag must be a U+003C LESS-THAN SIGN character (&lt;).2. The next few characters of a start tag must be the element’s tag name.3. If there are to be any attributes in the next step, there must first be one or more space characters.4. Then, the start tag may have a number of attributes, the syntax for which is described below. Attributes must be separated from each other by one or more space characters.5. After the attributes, or after the tag name if there are no attributes, there may be one or more space characters. (Some attributes are required to be followed by a space. See §8.1.2.3 Attributes below.)6. Then, if the element is one of the void elements, or if the element is a foreign element, then there may be a single U+002F SOLIDUS character (/). This character has no effect on void elements, but on foreign elements it marks the start tag as self-closing.7. Finally, start tags must be closed by a U+003E GREATER-THAN SIGN character (&gt;).</code></pre></blockquote><p>本来tagname应该是固定的，但是考虑到自定义标签，应当将范围扩大到合法的标识符，结合vue的源码，得到tagname模式为<code>[a-zA-z_][\s\-\.]*</code>。<br>这里有一点，由于tagname起码要有一个字符，因此第一个[]是必须有的，第二个[]是可选的，*只会修饰第二个[]。</p><p>可以根据上面的规则得出开标签的正则表达式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> startTagRe = <span class="regexp">/^&lt;([a-zA-z_][\s\-\.]*)(\s+([^\s"'&lt;&gt;\/=]+)(\s*=\s*(("([^"]*)")|('([^']*)')|[^\s"'=&lt;&gt;`]+))?)*\s*\/?\s*&gt;/</span></div></pre></td></tr></table></figure></p><h4 id="闭标签"><a href="#闭标签" class="headerlink" title="闭标签"></a>闭标签</h4><p>最后是闭标签</p><blockquote><p>End tags must have the following format:</p><pre><code>1. The first character of an end tag must be a U+003C LESS-THAN SIGN character (&lt;).2. The second character of an end tag must be a U+002F SOLIDUS character (/).3. The next few characters of an end tag must be the element’s tag name.4. After the tag name, there may be one or more space characters.5. Finally, end tags must be closed by a U+003E GREATER-THAN SIGN character (&gt;).</code></pre></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> endTagRe = <span class="regexp">/^&lt;[a-zA-Z_][\w\-\.]*\s*&gt;/</span></div></pre></td></tr></table></figure><h4 id="DOCTYPE"><a href="#DOCTYPE" class="headerlink" title="DOCTYPE"></a>DOCTYPE</h4><blockquote><p>A DOCTYPE must consist of the following components, in this order:</p><pre><code>1. A string that is an ASCII case-insensitive match for the string &quot;&lt;!DOCTYPE&quot;.2. One or more space characters.3. A string that is an ASCII case-insensitive match for the string &quot;html&quot;.4. Optionally, a DOCTYPE legacy string or an obsolete permitted DOCTYPE string (defined below).5. Zero or more space characters.6. A U+003E GREATER-THAN SIGN character (&gt;).</code></pre></blockquote><p>这里需要用到<code>[^&gt;]</code>了，因为这里并不能确定doctype后面会跟怎样的字符，而且这些字符必须存在<br>同时由于doctype是不区分大小写的，要加上ignore来修饰<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> doctypeRe = <span class="regexp">/!DOCTYPE [^&gt;]+&gt;/i</span></div></pre></td></tr></table></figure></p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注释不需要用正则表达式表达式匹配，找到注释的<code>&lt;!--</code>后直接寻找<code>--&gt;</code>就可以了</p><h3 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">parse: <span class="function"><span class="keyword">function</span>(<span class="params">html, handler</span>) </span>&#123;</div><div class="line">     <span class="keyword">while</span>(html.length &gt; <span class="number">0</span>) &#123;</div><div class="line">          <span class="comment">// main </span></div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (html.startsWith(<span class="string">'&lt;!--'</span>)) &#123;</div><div class="line">     <span class="keyword">let</span> index = html.indexOf(<span class="string">'--&gt;'</span>);</div><div class="line">     <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</div><div class="line">          html = <span class="string">''</span>;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          handler.handleComment(html.slice(<span class="number">4</span>, index));</div><div class="line">          html = html.slice(index + <span class="number">3</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">continue</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>匹配注释</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (doctypeRe.test(html)) &#123;</div><div class="line">     <span class="keyword">let</span> result = doctypeRe.exec(html);</div><div class="line">     handler.handleDoctype(result[<span class="number">0</span>]);</div><div class="line">     html = html.slice(result[<span class="number">0</span>].length);</div><div class="line">     <span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (startTagRe.test(html)) &#123;</div><div class="line">     <span class="keyword">let</span> result = startTagRe.exec(html);</div><div class="line">     handler.parseStartTag(result[<span class="number">0</span>]);</div><div class="line">     html = html.slice(result[<span class="number">0</span>].length);</div><div class="line">     <span class="keyword">continue</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (endTagRe.test(html)) &#123;</div><div class="line">     <span class="keyword">let</span> result = endTagRe.exec(html);</div><div class="line">     handler.handleEndTag(result[<span class="number">0</span>]);</div><div class="line">     html = html.slice(result[<span class="number">0</span>].length);</div><div class="line">     <span class="keyword">continue</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>doctype和开标签闭标签基本一样，而且也很简单，但是由于开标签需要额外进行一下属性处理，所以不直接调用handler</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> nextTag = html.index(<span class="string">'&lt;'</span>);</div><div class="line"><span class="keyword">if</span> (nextTag &lt; <span class="number">0</span>) &#123;</div><div class="line">     <span class="keyword">this</span>.handler.handleText(html);</div><div class="line">     html = <span class="string">''</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="keyword">this</span>.handler.handleText(html.slice(<span class="number">0</span>, nextTag));</div><div class="line">     html = html.slice(nextTag);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>倘若以上都没有匹配到的话，说明现在正在标签的内部，要检测的是文本</p><p>处理完以后需要寻找下一个标签，如果没有找到，那么剩下的html全部都是文本，如果找到了就截出需要的文本</p><hr><p><strong>parse开标签</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parseStartTag: <span class="function"><span class="keyword">function</span>(<span class="params">starTag</span>)</span></div></pre></td></tr></table></figure></p><p>首先要从开标签中找到tagname和属性<br>根据表达式/^&lt;([a-zA-z_][\s-.]<em>)(\s+([^\s”‘&lt;&gt;\/=]+)(\s</em>=\s<em>((“([^”]</em>)”)|(‘([^’]<em>)’)|[^\s”‘=&lt;&gt;`]+))?)</em>\s<em>\/?\s</em>&gt;/</p><p><code>$1</code>是<code>tagname</code>，<code>$2</code>是属性（如果有的话）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> match = startTagRe.exec(startTag);</div><div class="line"><span class="keyword">this</span>.handleStartTag(match[<span class="number">1</span>]);</div><div class="line"><span class="keyword">this</span>.parseAttributes(match[<span class="number">2</span>]);</div></pre></td></tr></table></figure><p><strong>parse属性</strong><br>/^\s+([^\s”‘&lt;&gt;\/=]+)(\s<em>=\s</em>((“([^”]<em>)”)|(‘([^’]</em>)’)|[^\s”‘=&lt;&gt;`]+))?/</p><p>这里进行分析的时候要用到replace，它会对global匹配的所有字符串进行函数的调用<br>对于属性，<code>$1</code>是<code>name</code>，<code>$2</code>是后半部分，可以用来判断是否存在值，<code>$3</code>是value部分，<code>$4</code>，<code>$5</code>是双引号和双引号内部的值，<code>$6</code>，<code>$7</code>是单引号及其内部的值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">parseAttributes: <span class="function"><span class="keyword">function</span>(<span class="params">attributes</span>) </span>&#123;</div><div class="line">     attributes.replce(attrRe, <span class="function"><span class="keyword">function</span>(<span class="params">attr, a1, a2, a3, a4, a5, a6, a7</span>) </span>&#123;</div><div class="line">          <span class="keyword">let</span> value = <span class="string">''</span>;</div><div class="line">          <span class="comment">// 是否是双引号</span></div><div class="line">          <span class="keyword">if</span> (a4) &#123;</div><div class="line">               value = a5;</div><div class="line">          <span class="comment">// 是否是单引号</span></div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a6) &#123;</div><div class="line">               value = a7;</div><div class="line">          <span class="comment">// 是否存在后半部分</span></div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a3) &#123;</div><div class="line">               value = a4;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// 检测空字符串的情况，并确认a3为空</span></div><div class="line">          <span class="keyword">let</span> empty = !value &amp;&amp; !a3;</div><div class="line">          handler.handleAttr(&#123;</div><div class="line">               name: a1,</div><div class="line">               value: empty ? <span class="literal">null</span> : value</div><div class="line">          &#125;);</div><div class="line">     &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><hr><p>以上就完成了文本解析的工作<br>关于handler的话，不同的需求实现也不同，不再多谈了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据上一篇文章，结合Vue源码，尝试进行一个简单的HTML-Parser实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript vue" scheme="http://yoursite.com/tags/javascript-vue/"/>
    
  </entry>
  
  <entry>
    <title>HTML-Parser 1</title>
    <link href="http://yoursite.com/2017/06/13/2017-06-13/"/>
    <id>http://yoursite.com/2017/06/13/2017-06-13/</id>
    <published>2017-06-12T16:00:00.000Z</published>
    <updated>2017-10-22T07:54:29.282Z</updated>
    
    <content type="html"><![CDATA[<p>Vue的注释中，有一个simplehtmlparser</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; HTML Parser By John Resig (ejohn.org)</div><div class="line">&gt; Modified by Juriy <span class="string">"kangax"</span> Zaytsev</div><div class="line">&gt; Original code by Erik Arvidsson, Mozilla Public License</div><div class="line">&gt; http:<span class="comment">//erik.eae.net/simplehtmlparser/simplehtmlparser.js</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><hr><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="startTag"><a href="#startTag" class="headerlink" title="startTag"></a>startTag</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">startTagRe:    <span class="regexp">/^&lt;([^&gt;\s\/]+)((\s+[^=&gt;\s]+(\s*=\s*((\"[^"]*\")|(\'[^']*\')|[^&gt;\s]+))?)*)\s*\/?\s*&gt;/m</span></div></pre></td></tr></table></figure><p>开标签的正则表达式<br>通常来说开标签的形式是形如<code>&lt;img src=&quot;./test.png&quot; /&gt;</code>这样的格式</p><blockquote><p><code>^&lt;</code>    以&lt;开头<br><code>([^&gt;\s\/]+)</code>    标签的tagName，这个tagName是紧紧跟在&lt;后面的，所以不能有空白。而标签又必须存在，&lt;后面不能直接跟/&gt;或&gt;，因此tagName必须是/和&gt;以外的字符且长度大于0<br>本来tagName还应该有其他的限制，如必须以字母或下划线开头，不能包含&lt;”‘等字符。但为了方便理解先不考虑。<br><code>(</code></p><blockquote><p><code>(</code><br><code>\s+</code>     img和src中间存在起码一个长度的空白<br><code>[^=&gt;\s]+</code>     属性名src，倘如存在属性的话，属性名也必须存在，所以不能直接跟=，&gt;和空白（属性名的合法性先不考虑</p><blockquote><p> <code>(</code><br><code>\s*=\s*</code>   <code>src=&quot;...&quot;</code>  中的<code>=</code>，两边允许有空白</p><blockquote><p><code>(</code><br><code>(\&quot;[^&quot;]*\&quot;)</code>    属性key=value中value的一种形式，如果value是”./xxx”这样的形式的话，双引号中间不能再有双引号<br>|<br><code>(\&#39;[^&#39;]*\&#39;)</code>     同上，value的单引号形式<br>|<br><code>[^&gt;\s]+</code>      value的第三种形式，形如checked=checked这样的形式，仅限于少数的几个属性（这里先不做限制考虑）<br>因为上面已经有了等号，所以后面不能为空，也不能直接跟&gt;</p><p><code>)</code></p></blockquote><p><code>)?</code>         这个括号中模式匹配的内容是<code>=&quot;./test.png&quot;</code>，由于有checked, disabled这样不需要赋值的属性存在，所以是可选的</p></blockquote><p><code>)*</code>         这个括号匹配的是<code>src=&quot;./test.png&quot;</code>，属性是可选的，因此有数量修饰符*</p></blockquote><p><code>)</code><br><code>\s*</code>     属性和/&gt;中间的空白<br><code>\/?</code>     部分自闭合标签如<code>&lt;img /&gt;</code>中的/，也是可选的<br><code>\s</code>      /和&gt;中间的空白<br><code>&gt;</code>     开标签的结尾&gt;</p></blockquote><p>看着很长，但是仔细分析一下的话也不算难理解，而且这个正则忽略了很多情况，但好在整体功能已经全备<br><code>m</code>修饰符表示会进行多行匹配</p><hr><h4 id="endTag"><a href="#endTag" class="headerlink" title="endTag"></a>endTag</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">endTagRe:    <span class="regexp">/^&lt;\/([^&gt;\s]+)[^&gt;]*&gt;/m</span></div></pre></td></tr></table></figure><p>闭标签<br>形如<code>&lt;/span&gt;</code><br><code>^&lt;</code>    以&lt;开头<br><code>\/</code>      &lt;之后的/<br><code>([^&gt;\s]+)</code>    span，标签名，必须存在<br><code>[^&gt;]*</code>    &gt;之前不能存在&gt;<br><code>&gt;</code>     最后的&gt;</p><hr><h4 id="attr"><a href="#attr" class="headerlink" title="attr"></a>attr</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">attrRe:        <span class="regexp">/([^=\s]+)(\s*=\s*((\"([^"]*)\")|(\'([^']*)\')|[^&gt;\s]+))?/gm</span></div></pre></td></tr></table></figure><p>属性的正则表达式，在开标签的表达式中已经包含它了</p><hr><h3 id="parse函数"><a href="#parse函数" class="headerlink" title="parse函数"></a>parse函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parse: <span class="function"><span class="keyword">function</span>(<span class="params">s, oHandler</span>)</span></div></pre></td></tr></table></figure><p><code>parse(s, oHandler)</code>接受两个参数，一个<code>s</code>，html的原字符串，另一个<code>oHandler</code>是对解析结果的处理函数</p><p>跳过变量定义和循环条件</p><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (s.substring(<span class="number">0</span>, <span class="number">4</span>) == <span class="string">"&lt;!--"</span>) &#123;</div><div class="line">     index = s.indexOf(<span class="string">"--&gt;"</span>);</div><div class="line">     <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</div><div class="line">          <span class="keyword">this</span>.contentHandler.comment(s.substring(<span class="number">4</span>, index));</div><div class="line">          s = s.substring(index + <span class="number">3</span>);</div><div class="line">          treatAsChars = <span class="literal">false</span>;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          treatAsChars = <span class="literal">true</span>;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果s以<code>&lt;!--</code>开头，说明现在要处理的是注释，那么就找到<code>--&gt;</code>的索引，把注释截出去交给handler处理<br>如果s没有<code>--&gt;</code>，那么说明s是纯文本，将<code>treatAsChars</code>置为true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.substring(<span class="number">0</span>, <span class="number">2</span>) == <span class="string">"&lt;/"</span>) &#123;</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.endTagRe.test(s)) &#123;</div><div class="line">          lc = <span class="built_in">RegExp</span>.leftContext;</div><div class="line">          lm = <span class="built_in">RegExp</span>.lastMatch;</div><div class="line">          rc = <span class="built_in">RegExp</span>.rightContext;</div><div class="line">          lm.replace(<span class="keyword">this</span>.endTagRe, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> oThis.parseEndTag.apply(oThis, <span class="built_in">arguments</span>);</div><div class="line">          &#125;</div><div class="line">          s = rc;</div><div class="line">          treatAsChars = <span class="literal">false</span>;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          treatAsChars = <span class="literal">true</span>;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这一段是处理闭标签，当s以<code>&lt;/</code>开头时，用闭标签的模式来进行匹配，如果匹配不到，就当作纯文本处理</p><p>如果能匹配的到，那么此时正则表达式的指针移动到了匹配的位置，<code>RegExp.leftContext</code>是匹配文本左边的部分，<code>RegExp.lastMatch</code>是匹配文本，而<code>RegExp.rightContext</code>就是右边的部分<br>这三个属性是落后的写法，现在应该用<code>String.Match()</code>更简便</p><p><code>lm.replace()</code>这一句的本意并非对lm进行替换操作，而是从lm中提取出匹配endtag的部分进行parse。<br><code>rc</code>便是匹配字符串剩下的部分，也就是剩下的html，继续循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">"&lt;"</span>) &#123;</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.startTagRe.test(s)) &#123;</div><div class="line">          lc = <span class="built_in">RegExp</span>.leftContext;</div><div class="line">          lm = <span class="built_in">RegExp</span>.lastMatch;</div><div class="line">          rc = <span class="built_in">RegExp</span>.rightContext;</div><div class="line">          lm.replace(<span class="keyword">this</span>.startTagRe, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> oThis.parseStargTag.apply(oThis, <span class="built_in">arguments</span>);</div><div class="line">          &#125;</div><div class="line">          s = rc;</div><div class="line">          treatAsChars = <span class="literal">false</span>;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          treatAsChars = <span class="literal">true</span>;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>处理开标签，和闭标签没什么区别</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (treatAsChars) &#123;</div><div class="line">     index = s.indexOf(<span class="string">"&lt;"</span>);</div><div class="line">     <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</div><div class="line">          <span class="keyword">this</span>.contentHandler.characters(s);</div><div class="line">          s = <span class="string">""</span>;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">this</span>.contentHandler.characters(s.substring(<span class="number">0</span>, index));</div><div class="line">          s = substring(index);</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>处理纯文本，首先要确定纯文本到底有多长，也就是找到下一个tag的位置，即<code>&lt;</code>在s中的索引</p><p>如果<code>&lt;</code>没有了，也就是s剩下的全都是文本，直接交给handler<br>如果找到了<code>&lt;</code>，那么就截出文本交给handler，剩下的部分继续循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">treatAsChars = <span class="literal">true</span>;</div></pre></td></tr></table></figure><p>倘若上面那些关于注释和标签的判断都没有命中，那么就当作纯文本，会在下一个循环的时候被处理</p><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">parseStartTag: <span class="function"><span class="keyword">function</span>(<span class="params">sTag, sTagName, sRest</span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> attrs = <span class="keyword">this</span>.parseAttributes(sTagName, sRest);</div><div class="line">     <span class="keyword">this</span>.contentHandler.startElement(sTagName, attrs);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里是对开标签进行parse<br>由于上下文环境是<code>oThis</code>，因此可以照常调用<code>this</code><br>这个函数是作为replace函数的replacer而存在的，观察startTag的正则表达式可以知道<br><code>p0</code>是整个标签，<code>p1</code>是<code>tagName</code>，<code>p2</code>是属性，分别对应<code>sTag</code>, <code>sTagName</code>, <code>sRest</code><br>继续parse属性，然后把结果和tagname一起交给handler</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">parseEndTag: <span class="function"><span class="keyword">function</span>(<span class="params">sTag, sTagName</span>) </span>&#123;</div><div class="line">     <span class="keyword">this</span>.contentHandler.endElement(sTagName);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>闭标签的<code>p0</code>是整个标签，<code>p1</code>是tagname</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">parseAttributes: <span class="function"><span class="keyword">function</span>(<span class="params">sTagName, s</span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> oThis = <span class="keyword">this</span>;</div><div class="line">     <span class="keyword">var</span> attrs = [];</div><div class="line">     s.replace(<span class="keyword">this</span>.attrRe, <span class="function"><span class="keyword">function</span>(<span class="params">a0, a1, a2, a3, a4, a5, a6</span>) </span>&#123;</div><div class="line">          attrs.push(oThis.parseAttribute(sTagName, a0, a1, a2, a3, a4, a5, a6));</div><div class="line">     &#125;);</div><div class="line">     <span class="keyword">return</span> attrs;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个s是包含所有的属性在内的字符串<br>因此使用replace找到所有匹配属性的字符串分别进行处理，并放入attrs数组中，最后返回attrs<br>对于属性<code>type=&quot;text&quot;</code><br>a0: <code>match</code> – <code>type=&quot;text&quot;</code><br>a1: <code>([^=\s]+)</code> –     <code>type</code><br>a2: <code>(\s*=\s*((\&quot;([^&quot;]*)\&quot;)|(\&#39;([^&#39;]*)\&#39;)|[^&gt;\s]+))</code> –  <code>=&quot;text&quot;</code><br>a3: <code>((\&quot;([^&quot;]*)\&quot;)|(\&#39;([^&#39;]*)\&#39;)|[^&gt;\s]+)</code>  –  <code>&quot;text&quot;</code><br>a4: <code>(\&quot;([^&quot;]*)\&quot;)</code> – <code>&quot;text&quot;</code><br>a5: <code>([^&quot;]*)</code> –  <code>text</code><br>a6: <code>(\&#39;([^&#39;]*)\&#39;)</code>   –  <code>undefined</code><br>a7: <code>([^&#39;]*)</code>  –  <code>undefined</code><br>a8: <code>offset</code> –  <code>0</code><br>a9: <code>string</code>  – <code>type=&quot;text&quot;</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">parseAttributes: <span class="function"><span class="keyword">function</span>(<span class="params">sTagName, sAttribute, sName</span>) </span>&#123;</div><div class="line">     <span class="keyword">var</span> value = <span class="string">""</span>;</div><div class="line">     <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">7</span>]) &#123;</div><div class="line">          value = <span class="built_in">arguments</span>[<span class="number">8</span>];</div><div class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">5</span>]) &#123;</div><div class="line">          value = <span class="built_in">arguments</span>[<span class="number">6</span>];</div><div class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">3</span>]) &#123;</div><div class="line">          value = <span class="built_in">arguments</span>[<span class="number">4</span>];</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">var</span> empty = !value &amp;&amp; !<span class="built_in">arguments</span>[<span class="number">3</span>];</div><div class="line">     <span class="keyword">return</span> &#123;</div><div class="line">          name: sName,</div><div class="line">          value: empty ? <span class="literal">null</span> : value</div><div class="line">     &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><code>arguments[7] ==&gt; a6</code> 单引号的情况，如果a6有值，那就取出aruments[8]也就是a7的值<br><code>arguments[5] ==&gt; a4</code> 双引号的情况，同上，如果有值就取a5<br><code>arguments[3] ==&gt; a2</code> 整个后半部分。如果既不是单引号也不是双引号，而a2有值，那么说明是<code>checked=checked</code>的情况，这个时候直接a3的值为去掉等号的<code>checked</code><br>如果遍历完情况value的值依然为空，那么就检查一下a2是否为空，如果a2也为空，说明是<code>checked</code>的形式，value为<code>null</code></p><p>为什么要对<code>arguments[3]</code>进行一次重复的判断？<br>因为可能存在value为空字符串的情况<br>如果value是空字符串，那么<code>!value === true &amp;&amp; !arguments[3] === false</code>这种情况是存在的，此时显然不能将value设置为null<br>而<code>arguments[3]</code>如果为空，那么value一定不存在，可以安心将它设置为null</p><hr><blockquote><p>勘误：关于<code>checked=checked</code>，并非是只有这种情况。HTML标准并没有强制要求value要加引号，只不过不加引号常常会导致引发错误如<code>&lt;img src=w3c school&gt;</code>所以不怎么推荐使用。因此，属性判断中的第三个条件是对这种情况的处理</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue的注释中，有一个simplehtmlparser&lt;/p&gt;
&lt;blockquote&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
    
      <category term="javascript vue" scheme="http://yoursite.com/tags/javascript-vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue源码零碎笔记</title>
    <link href="http://yoursite.com/2017/06/09/2017-06-09/"/>
    <id>http://yoursite.com/2017/06/09/2017-06-09/</id>
    <published>2017-06-08T16:00:00.000Z</published>
    <updated>2017-10-22T08:49:36.228Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</div></pre></td></tr></table></figure><p>创建一个干净的、原型链上不存在任何父对象的对象。<br>普通的<code>{}</code>的constructor是<code>Object</code>，它继承Object.prototype的所有方法，相当于<code>Object.create(Object.prototype)</code><br>而<code>Object.create(null)</code>创建的对象的constructor是<code>null</code>，没有Object原生的方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = &#123;&#125;, p2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line">p1.toString;   <span class="comment">//  function() &#123;...&#125;</span></div><div class="line">p2.toString;   <span class="comment">//  undefined</span></div></pre></td></tr></table></figure></p><p>详情：<a href="https://stackoverflow.com/questions/15518328/creating-js-object-with-object-createnull" target="_blank" rel="external">https://stackoverflow.com/questions/15518328/creating-js-object-with-object-createnull</a></p><a id="more"></a><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str.replace(regexp|substr, newSubStr|<span class="function"><span class="keyword">function</span>)</span></div></pre></td></tr></table></figure><p><code>replace</code>第二个参数可以接受一个函数replacer来创建新的替换的字符串，当第一个参数是正则表达式且包含g参数时，每次进行替换操作都会调用函数</p><p><code>replacer(match, p1, p2,..., offset, string)</code><br><code>match</code>是匹配到的子字符串<br><code>p1, p2...</code>是正则表达式中第n个括号匹配到的内容（子正则匹配到的内容））<br><code>offset</code>是match在string中的偏移量<br><code>string</code>是原字符串</p><hr><p>短语元素：能被放在一个段落中的元素，如<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>等<br>而<code>&lt;article&gt;&lt;h1&gt;&lt;h2&gt;</code>这些不能被放在一个段落中，就不是短语元素<br><a href="https://stackoverflow.com/questions/30233447/what-is-the-difference-between-phrasing-content-and-flow-content" target="_blank" rel="external">https://stackoverflow.com/questions/30233447/what-is-the-difference-between-phrasing-content-and-flow-content</a></p><hr><p><code>str.match()</code><br>返回一个数组，数组的第一位是捕获结果<br>子捕获组会跟在捕获结果的后面<br>除此之外数组还有两个属性。一个index表示结果位置，一个input是原字符串<br><code>str.match(re)</code>和<code>re.exec(str)</code>返回同样的结果</p><hr><p><code>str.substring(indexStart[, indexEnd])</code><br><code>str.substr(start, length)</code><br><code>str.slice(start[, end])</code><br>区别：<br><code>substr</code>第二个参数取的是长度，这个不谈</p><p><code>substring</code>和<code>slice</code>最主要的区别在于，如果参数二小于参数一，slice会取空，而substring会交换二者取值<br>而如果第二个参数是负数，slice会从字符串末尾开始算位置，substring会将其视为0，之后如果第一个参数大于0，交换0和第一个参数取值<br>注意substring和slice取值是<strong>不包括</strong>end的——[index, end)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="string">'0123456789'</span>;</div><div class="line">a.slice(<span class="number">3</span>, <span class="number">-3</span>)</div><div class="line">&gt; <span class="string">"3456"</span>  <span class="comment">//  a.slice(3, -3) =&gt; a.slice(3, 7)</span></div><div class="line">a.substring(<span class="number">3</span>, <span class="number">-3</span>)</div><div class="line">&gt; <span class="string">"012"</span>   <span class="comment">//  a.substring(3, -3) =&gt; a.substring(3, 0) =&gt; a.substring(0, 3)</span></div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (result = re.exec(text)) &#123; ... &#125;</div></pre></td></tr></table></figure><p>这个if判断的是后面赋值语句执行完毕后<code>result</code>的真值</p><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tokens.push(<span class="built_in">JSON</span>.stringify(text.slice(lastIndex, index)));</div></pre></td></tr></table></figure><p><code>JSON.stringify()</code>会为<code>slice()</code>返回的字符串再添加一对引号</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; cache = &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.create(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;创建一个干净的、原型链上不存在任何父对象的对象。&lt;br&gt;普通的&lt;code&gt;{}&lt;/code&gt;的constructor是&lt;code&gt;Object&lt;/code&gt;，它继承Object.prototype的所有方法，相当于&lt;code&gt;Object.create(Object.prototype)&lt;/code&gt;&lt;br&gt;而&lt;code&gt;Object.create(null)&lt;/code&gt;创建的对象的constructor是&lt;code&gt;null&lt;/code&gt;，没有Object原生的方法&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p1 = &amp;#123;&amp;#125;, p2 = &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.create(&lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;p1.toString;   &lt;span class=&quot;comment&quot;&gt;//  function() &amp;#123;...&amp;#125;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;p2.toString;   &lt;span class=&quot;comment&quot;&gt;//  undefined&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;详情：&lt;a href=&quot;https://stackoverflow.com/questions/15518328/creating-js-object-with-object-createnull&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://stackoverflow.com/questions/15518328/creating-js-object-with-object-createnull&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue 笔记" scheme="http://yoursite.com/tags/vue-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Vue问题笔记</title>
    <link href="http://yoursite.com/2017/05/14/2017-05-14/"/>
    <id>http://yoursite.com/2017/05/14/2017-05-14/</id>
    <published>2017-05-13T16:00:00.000Z</published>
    <updated>2017-10-22T08:49:08.502Z</updated>
    
    <content type="html"><![CDATA[<h4 id="vue-router2的变化"><a href="#vue-router2的变化" class="headerlink" title="vue-router2的变化"></a>vue-router2的变化</h4><p><code>vue-router2</code>改了<code>router.map()</code>和<code>router.start()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</div><div class="line">    [</div><div class="line">        &#123; <span class="attr">path</span>: <span class="string">'/list'</span>, <span class="attr">component</span>: list, <span class="attr">alias</span>: <span class="string">'/'</span> &#125;,</div><div class="line">        <span class="comment">// 添加一个别名'/'来指定默认页面</span></div><div class="line">        &#123; <span class="attr">path</span>: <span class="string">'/detail'</span>, <span class="attr">component</span>: detail &#125;,</div><div class="line">        &#123; <span class="attr">path</span>: <span class="string">'/edit'</span>, <span class="attr">component</span>: edit &#125;</div><div class="line">    ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><code>router.start()</code>被弃用，现在要在配置vue对象的时候注入上面的router</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">    router,</div><div class="line">    components: &#123;</div><div class="line">        app</div><div class="line">    &#125;</div><div class="line">&#125;).$mount(<span class="string">'#app'</span>)</div></pre></td></tr></table></figure><a id="more"></a><hr><h4 id="vuex2的变化"><a href="#vuex2的变化" class="headerlink" title="vuex2的变化"></a>vuex2的变化</h4><p>vuex2相比以前用的0.6来说改了不少，但是大部分都是一些变量名的更改，整体思路个人感觉变化不大<br>最显著的变化应该是<code>modules</code>了吧<br><code>modules</code>就是一个子<code>vuex</code>，有自己独立的<code>state</code>, <code>getters</code>, <code>mutations</code>和<code>actions</code>，除了<code>state</code>之外其他都是暴露在外部的</p><hr><h4 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h4><p>在使用某个action的时候发现总是会有参数莫名其妙的变成<code>undefined</code>，用log打印了一下，发现在调用action的时候参数压根都没有传过去<br>比如<code>update(id, value)</code>，结果传过来的只有<code>id</code>，<code>value</code>是<code>undefined</code></p><p>思考了好久，突然在debug tools看到一个叫<code>payload</code>的对象，然后就想起vuex2里面好像是新加了这个设定<br>如果只有一个参数，这个参数就被js当作了<code>payload</code>，因此不会有问题<br>放进去多个参数的时候，却只有第一个参数会被当作<code>payload</code>传入<code>action</code><br>因此需要改为<code>update({id: id, value: value})</code></p><hr><h4 id="vuex和表单处理"><a href="#vuex和表单处理" class="headerlink" title="vuex和表单处理"></a>vuex和表单处理</h4><p><code>vuex</code>的官方文档中也有提到，<code>vuex</code>在和<code>v-model</code>搭配使用的时候，由于<code>v-model</code>会直接修改对象，这个修改是不在<code>mutation</code>中执行的，很容易出问题</p><p>官方文档给了两种解决方案，一种是为对象设置<code>getter</code>和<code>setter</code>，<code>v-model</code>更改对象的时候会调用<code>setter</code>函数，这时候<code>commit mutation</code>就可以了</p><p>但是如果对象是动态的话，上面的方法就不好使了。这种情况最好监听<code>input</code>或者<code>change</code>事件，不使用<code>v-model</code>，在事件的回调函数中<code>commit mutation</code></p><hr><h4 id="vue的视图更新"><a href="#vue的视图更新" class="headerlink" title="vue的视图更新"></a>vue的视图更新</h4><p>直接通过索引修改数组的话无法触发视图更新<br>比如<code>arr[index] = val</code>，数据层虽然将<code>index</code>修改为<code>val</code>，但是视图不会跟着更新，需要使用<code>vue</code>包装过的方法<code>arr.splice(index, 1, val)</code>来触发更新</p><p>除此之外直接修改数组的长度也会导致视图不更新，解决方法是<code>arr.splice(newLength)</code><br><code>splice</code>只接受一个参数的时候会截取至<code>index</code>为<code>newLength</code>的元素，也就是截取成<code>newLength</code>长度</p><hr><h4 id="beforeRouteEnter"><a href="#beforeRouteEnter" class="headerlink" title="beforeRouteEnter"></a>beforeRouteEnter</h4><p><code>vue-router2</code>中，导航钩子<code>beforeRouteEnter</code>可以在渲染组件的路由被<code>confirm</code>之前调用，也就是说只有这个钩子<code>resolve</code>之后才会渲染组件<br><code>beforeRouteEnter(to, from, next)</code>，<code>to</code>和<code>from</code>是路由对象，即<code>this.$route</code>，包含<code>path</code>, <code>params</code>, <code>query</code>等信息<br>值得一提的是在这个钩子中不能访问this，因为此时导航还没有被确认，组件尚未被创建，要使用this可以在<code>next</code>中添加一个回调函数<code>next()</code>来<code>resolve</code>这个钩子，<code>next(&#39;/&#39;)</code>或者<code>next({ path: &#39;/&#39; })</code>来重定向，<code>next(false)</code>来中断路由，会返回到from路由对应的地址</p><hr><h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><p>使用<code>install</code>注册插件，如果需要在模板中使用这个函数就在<code>data</code>中返回</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;vue-router2的变化&quot;&gt;&lt;a href=&quot;#vue-router2的变化&quot; class=&quot;headerlink&quot; title=&quot;vue-router2的变化&quot;&gt;&lt;/a&gt;vue-router2的变化&lt;/h4&gt;&lt;p&gt;&lt;code&gt;vue-router2&lt;/code&gt;改了&lt;code&gt;router.map()&lt;/code&gt;和&lt;code&gt;router.start()&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; router = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; VueRouter(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    [&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#123; &lt;span class=&quot;attr&quot;&gt;path&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;/list&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;component&lt;/span&gt;: list, &lt;span class=&quot;attr&quot;&gt;alias&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;/&#39;&lt;/span&gt; &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 添加一个别名&#39;/&#39;来指定默认页面&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#123; &lt;span class=&quot;attr&quot;&gt;path&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;/detail&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;component&lt;/span&gt;: detail &amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#123; &lt;span class=&quot;attr&quot;&gt;path&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;/edit&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;component&lt;/span&gt;: edit &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;router.start()&lt;/code&gt;被弃用，现在要在配置vue对象的时候注入上面的router&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Vue(&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    router,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    components: &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        app&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;).$mount(&lt;span class=&quot;string&quot;&gt;&#39;#app&#39;&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="笔记 vue javascript" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0-vue-javascript/"/>
    
  </entry>
  
  <entry>
    <title>Vue2简易环境搭建</title>
    <link href="http://yoursite.com/2017/04/23/2017-04-23/"/>
    <id>http://yoursite.com/2017/04/23/2017-04-23/</id>
    <published>2017-04-22T16:00:00.000Z</published>
    <updated>2017-10-22T08:48:47.685Z</updated>
    
    <content type="html"><![CDATA[<p>主要使用<code>vue2</code>，<code>vuex2</code>进行状态管理，<code>vue-router2</code>控制路由跳转，<code>webpack</code>打包。</p><a id="more"></a><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cnpm install vue vue-router vuex --save</div></pre></td></tr></table></figure><p>webpack及其组件：</p><ul><li><p>babel-loader, 按照vue2.0x的官方文档，对象展开运算符需要支持到stage-3阶段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cnpm install webpack babel-core babel-loader babel-preset-stage-3 --save-dev</div></pre></td></tr></table></figure></li><li><p><code>vue-loader</code>处理vue文件</p></li><li><code>sass-loader</code>进行css的预处理</li><li><code>css-loader</code>来处理url()表达式</li><li><code>style-loader</code>来将样式插入style标签</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cnpm install vue-loader sass-loader css-loader style-loader --save-dev</div></pre></td></tr></table></figure><h3 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    entry,</div><div class="line">    output,</div><div class="line">    resolve: &#123;</div><div class="line">        extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>]</div><div class="line">        <span class="comment">// extensions用来为引用模块自动补全后缀</span></div><div class="line">    &#125;,</div><div class="line">    <span class="built_in">module</span>: &#123;</div><div class="line">        loaders: [</div><div class="line">            &#123;</div><div class="line">                test: <span class="regexp">/\.vue$/</span>,</div><div class="line">                loader: <span class="string">'vue-loader'</span></div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                test: <span class="regexp">/\.js$/</span>,</div><div class="line">                exclude: <span class="regexp">/node_modules/</span>,</div><div class="line">                <span class="comment">// 不处理node_modules目录下的js后缀文件</span></div><div class="line">                loader: <span class="string">'babel-loader'</span></div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                test: <span class="regexp">/\.sass$/</span>,</div><div class="line">                loader: <span class="string">'style-loader!css-loader!sass-loader'</span></div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在根目录下添加<code>.babelrc</code>来配置babel<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"presets"</span>: [</div><div class="line">        <span class="string">"stage-3"</span></div><div class="line">    ],</div><div class="line">    <span class="string">"plugins"</span>: []</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h5 id="1-Error-Cannot-find-module-‘node-sass’"><a href="#1-Error-Cannot-find-module-‘node-sass’" class="headerlink" title="1. Error: Cannot find module ‘node-sass’"></a>1. Error: Cannot find module ‘node-sass’</h5><p>sass-loader现在需要依赖node-sass插件</p><blockquote><p>The sass-loader requires node-sass and webpack as peerDependency. Thus you are able to control the versions accurately.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cnpm install node-sass --save-dev</div></pre></td></tr></table></figure><h5 id="2-独立构建"><a href="#2-独立构建" class="headerlink" title="2. 独立构建"></a>2. 独立构建</h5><p><code>vue2</code>有独立构建和运行时构建两种构建方法。<br>独立构建包含模板编辑器，可以在文件中使用<code>template</code>写模板，因而它依赖于浏览器，不能在服务器中使用<br>运行时构建不包含模板编辑器，不支持<code>template</code>，只能使用<code>render</code>选项来渲染，因而比独立构建要轻量</p><p>默认使用的运行时构建，我为了省事使用的独立构建，所以需要在webpack中添加配置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">    alias: &#123;</div><div class="line">        <span class="string">'vue$'</span>: <span class="string">'vue/dist/vue.common.js'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个应该是用<code>vue.common.js</code>来替换npm包中默认导出的<code>vue</code>文件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要使用&lt;code&gt;vue2&lt;/code&gt;，&lt;code&gt;vuex2&lt;/code&gt;进行状态管理，&lt;code&gt;vue-router2&lt;/code&gt;控制路由跳转，&lt;code&gt;webpack&lt;/code&gt;打包。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Underscore数组乱序的实现</title>
    <link href="http://yoursite.com/2017/04/15/2017-04-15-1/"/>
    <id>http://yoursite.com/2017/04/15/2017-04-15-1/</id>
    <published>2017-04-14T16:00:00.000Z</published>
    <updated>2017-10-22T08:52:24.647Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">_.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> set = isArrayLike(obj) ? obj : _.values(obj);</div><div class="line">    <span class="keyword">var</span> length = set.length;</div><div class="line">    <span class="keyword">var</span> shuffled = <span class="built_in">Array</span>(length);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>, rand; index &lt; length; index++) &#123;</div><div class="line">        rand = _.random(<span class="number">0</span>, index);</div><div class="line">        <span class="keyword">if</span> (rand !== index)</div><div class="line">            shuffled[index] = shuffled[rand];</div><div class="line">        shuffled[rand] = set[index];</div></pre></td></tr></table></figure><p><code>_.shuffle()</code>接受一个<code>obj</code>，这个<code>obj</code>可以是类数组元素或者对象元素</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> set = isArrayLike(obj) ? obj : _.values(obj);</div></pre></td></tr></table></figure><p>如果是类数组元素，直接对它进行处理<br>如果是个对象元素，处理它的值的数组<br><code>set</code>用来存放这个保存结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> shuffled = <span class="built_in">Array</span>(length);</div></pre></td></tr></table></figure><p><code>shuffled</code>用来存放输出结果，此时先初始化一个空数组</p><p>随后遍历<code>set</code></p><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rand = _.random(<span class="number">0</span>, index);</div></pre></td></tr></table></figure><p>生成一个<code>[0, index]</code>的随机整数</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment">// _.random()接受一个最小值和最大值（包括）作为区间</span></div><div class="line">&gt; _.random = <span class="function"><span class="keyword">function</span>(<span class="params">min, max</span>) </span>&#123;</div><div class="line">&gt;     <span class="comment">// 如果只有一个参数，如_.random(n)，被视为_.random(0, n)</span></div><div class="line">&gt;     <span class="keyword">if</span> (max == <span class="literal">null</span>) &#123;</div><div class="line">&gt;         max = min;</div><div class="line">&gt;         min = <span class="number">0</span>;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;     <span class="keyword">return</span> min + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>));</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>为什么求随机数的时候要使用Math.floor(Math.random() * (max - min + 1))？</p><p>根据W3C的给Math.random()的定义：</p><blockquote><p>The random() method returns a random number from 0 (inclusive) up to but not including 1 (exclusive).</p></blockquote><p> 可以知道Math.random()取值范围是[0, 1)<br> 假如我们要取[0, 5]之间的随机数，而使用Math.random() (5 - 0)的话，会得到[0, 5)，没有覆盖到5<br>因此应该使用Math.random() (5 - 0 + 1)，这样取值范围是[0, 6)，与此同时，为了返回一个整数，我们使用Math.floor()进行处理，可以保证取到每一个整数的概率是均匀的<br>Math.floor(Math.random() * (m - n + 1))中取每个整数的概率大致上是这样的：<br>0–&lt;–|1–&lt;–|2–&lt;…&lt;–|(m - n)–&lt;–|m - n + 1</p></blockquote><hr><p>接着分析<code>shuffle</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (rand !== index)</div><div class="line">    shuffled[index] = shuffled[rand]</div><div class="line">shuffled[rand] = set[index];</div></pre></td></tr></table></figure><p>这一段很好理解，如果<code>rand !== index</code>，就交换二者<br>如果<code>rand === index</code>，等同于<code>shuffled[index] = set[index]</code><br><code>set</code>在这里已经充当了数值交换中<code>temp</code>的身份</p><p>这里underscore使用的是一个叫<code>Fisher-Yates shuffle</code>乱序算法的修改版，可以参考：<a href="https://www.h5jun.com/post/array-shuffle.html" target="_blank" rel="external">https://www.h5jun.com/post/array-shuffle.html</a></p><p>最后返回乱序过的数组</p><hr><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>我们可以藉此写出一个简易的打乱数组的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> result = <span class="built_in">Array</span>(array.length);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, rand; i &lt; result.length; i++) &#123;</div><div class="line">        rand = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>));</div><div class="line">        <span class="keyword">if</span> (rand !== i) result[i] = result[rand];</div><div class="line">        result[rand] = array[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如果给定一个数组，要求返回n个数组中不重复的随机元素，就可以先打乱数组，然后返回长度为n的切片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sample_shuffle</span>(<span class="params">array, n</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> shuffle(array).slice(<span class="number">0</span>, <span class="built_in">Math</span>.max(<span class="number">0</span>, n));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Math.max(0, n)</code>可以将<code>n &lt; 0</code>的不合法情况统一视作<code>n === 0</code></p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;_.shuffle = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; set = isArrayLike(obj) ? obj : _.values(obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; length = set.length;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; shuffled = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(length);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, rand; index &amp;lt; length; index++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        rand = _.random(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, index);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (rand !== index)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            shuffled[index] = shuffled[rand];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        shuffled[rand] = set[index];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;_.shuffle()&lt;/code&gt;接受一个&lt;code&gt;obj&lt;/code&gt;，这个&lt;code&gt;obj&lt;/code&gt;可以是类数组元素或者对象元素&lt;/p&gt;
    
    </summary>
    
    
      <category term="underscore javascript" scheme="http://yoursite.com/tags/underscore-javascript/"/>
    
  </entry>
  
  <entry>
    <title>Underscore零碎笔记</title>
    <link href="http://yoursite.com/2017/04/15/2017-04-15/"/>
    <id>http://yoursite.com/2017/04/15/2017-04-15/</id>
    <published>2017-04-14T16:00:00.000Z</published>
    <updated>2017-10-22T08:52:16.169Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// underscore的核心函数，返回一个wrapped属性为obj的实例对象。</span></div><div class="line"><span class="keyword">var</span> _ = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="comment">// 若obj已经是_的一个实例，就直接返回</span></div><div class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;</div><div class="line">  <span class="comment">// 若不是通过new调用的函数，就返回一个通过new创建的obj实例</span></div><div class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);</div><div class="line">  <span class="comment">// 通过new创建才会触发这一步，将obj赋给实例对象的wrapped属性</span></div><div class="line">  <span class="keyword">this</span>.wrapped = obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这个函数创建一个包含有<code>wrapped: obj</code>属性的对象</p><a id="more"></a><p>如果通过<code>new _(obj)</code>来调用，此时<code>this instanceof _</code>为<code>true</code>，直接为this添加属性<br>如果是以<code>_(obj)</code>的方式调用，返回<code>new _(obj)</code></p><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回一个this指向context的func函数</span></div><div class="line"><span class="keyword">var</span> optimizeCb = <span class="function"><span class="keyword">function</span>(<span class="params">func, context, argCount</span>) </span>&#123;</div><div class="line">  <span class="comment">// 若没有给出context参数，直接返回func</span></div><div class="line">  <span class="keyword">if</span> (context === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> func;</div><div class="line">  <span class="comment">// 根据参数数量决定使用call还是apply</span></div><div class="line">  <span class="keyword">switch</span> (argCount == <span class="literal">null</span> ? <span class="number">3</span> :argCount) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.call(context,value);</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value, other</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.call(context, value, other);</div><div class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value, index, collection</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.call(context, value, index, collection);</div><div class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">accumulator, value, index, collection</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> func.call(context, accumulator, value, index, collection);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> func.apply(context, <span class="built_in">arguments</span>);</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>看起来很复杂的函数，但是本质上只有<code>return func.apply(context, arguments);</code>这一句</p><p>switch语句在这里起到一个优化的作用<br><code>.call()</code> 的调用速度比<code>.apply()</code>要快一些，因此针对<code>argCount&lt;=4</code>的情况专门做了个优化</p><blockquote><p>为什么使用<code>void 0</code>？<br><code>undefined</code>并不是一个保留字，在低版本的浏览器中可能被重写；<br><code>void</code>操作符会计算紧跟在后面的表达式并返回一个undefined</p></blockquote><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建reduce函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReduce</span>(<span class="params">dir</span>) </span>&#123;</div><div class="line">    <span class="comment">// 执行迭代reduce的部分</span></div><div class="line">    <span class="comment">// obj =&gt; 执行对象</span></div><div class="line">    <span class="comment">// iteratee =&gt; reduce中处理转换数据的函数</span></div><div class="line">    <span class="comment">//          iteratee(memo, value, key, obj)</span></div><div class="line">    <span class="comment">// memo =&gt; reduce初始值，reduce会在memo上面进行</span></div><div class="line">    <span class="comment">// keys =&gt; 若obj不是一个类数组对象，keys应当是obj的键的数组</span></div><div class="line">    <span class="comment">// index =&gt; 起始索引</span></div><div class="line">    <span class="comment">// length =&gt; obj或obj的keys的长度</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="comment">// 若obj是一个类数组对象，遍历obj；否则，遍历obj的key</span></div><div class="line">    <span class="comment">// iteratee应当对将结果保存在第一个参数memo上</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params">obj, iteratee, memo, keys, index, length</span>) </span>&#123;</div><div class="line">        <span class="keyword">for</span> (; index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length; index += dir) &#123;</div><div class="line">            <span class="keyword">var</span> currentKey = keys ? keys[index] : index;</div><div class="line">            memo = iteratee(memo, obj[currentKey], currentKey, obj);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> memo;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, memo, context</span>) </span>&#123;</div><div class="line">        <span class="comment">// 将iteratee转换为在context下执行的回调函数</span></div><div class="line">        iteratee = optimizeCb(iteratee, context, <span class="number">4</span>);</div><div class="line">        <span class="keyword">var</span> keys = !isArrayLike(obj) &amp;&amp; _.keys(obj),</div><div class="line">            length = (keys || obj).length,</div><div class="line">            <span class="comment">// dir &gt; 0，从左向右reduce，从0开始</span></div><div class="line">            <span class="comment">// dir &lt; 0, 从右向左reduce，从最后开始</span></div><div class="line">            index = dir &gt; <span class="number">0</span> ? <span class="number">0</span> : length - <span class="number">1</span>;</div><div class="line">        <span class="comment">// 若没有指定memo，使用index处的value值作为memo初始值，并更新index</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">3</span>) &#123;</div><div class="line">            memo = object[keys ? keys[index] : index];</div><div class="line">            index += dir;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 返回reduce结果</span></div><div class="line">        <span class="keyword">return</span> iterator(obj, iteratee, memo, keys, index, length);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">_.sortBy = <span class="function"><span class="keyword">function</span>(<span class="params">obj, iteratee, context</span>) </span>&#123;</div><div class="line">    iteratee = cb(iteratee, context);</div><div class="line">    <span class="keyword">return</span> _.pluck(_.map(obj, <span class="function"><span class="keyword">function</span>(<span class="params">value, index, list</span>) </span>&#123;</div><div class="line">        <span class="comment">// 遍历obj，返回&#123;value, index, criteria&#125;格式的对象数组</span></div><div class="line">        <span class="comment">// 其中criteria是执行iteratee后，返回判断基准</span></div><div class="line">        <span class="comment">// value属性方便进行pluck操作</span></div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            value: value,</div><div class="line">            index: index,</div><div class="line">            criteria: iteratee(value, inded, list)</div><div class="line">        &#125;;</div><div class="line">    &#125;).sort(<span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> a = left.criteria;</div><div class="line">        <span class="keyword">var</span> b = right.criteria;</div><div class="line">        <span class="keyword">if</span> (a !== b) &#123;</div><div class="line">        <span class="comment">// undefined排到后面</span></div><div class="line">            <span class="keyword">if</span> (a &gt; b || a === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span> (a &lt; b || b === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> left.index - right.index;</div><div class="line">    &#125;), <span class="string">'value'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>本质上可以简化为<code>_.pluck(obj.sort(), ‘value’)</code><br>先遍历obj，将obj转换为特定格式的对象组成的数组<br>然后对进行sort操作，最后取出对象的<code>value</code>属性</p><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hasEnumBug = !&#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;.propertyIsEnumerable(<span class="string">'toString'</span>);</div></pre></td></tr></table></figure><p>正常情况下诸如<code>toString</code>这样的属性是不可枚举的，在<code>for key in obj</code>这种循环中是不会出现的<br>但是如果重写了<code>toString</code>属性，比如<code>{toString: function() {alert(1)}</code>这样，<code>toString</code>会被覆盖为可枚举的<br>但是IE&lt;9的浏览器中有一个bug，默认不可枚举的属性即使被同名可枚举的属性覆盖，也依然不可枚举<br>因此这一段代码就是用来判断是否有这个bug<br><a href="http://stackoverflow.com/questions/7367519/ie8-property-enumeration-of-replaced-built-in-properties-e-g-tostring" target="_blank" rel="external">http://stackoverflow.com/questions/7367519/ie8-property-enumeration-of-replaced-built-in-properties-e-g-tostring</a></p><blockquote><p><code>obj.propertyIsEnumerable(key)</code>：判断obj的key是否可枚举，返回boolean<br><code>obj.hasOwnProperty(key)</code>：判断obj的key是来自自身还是来自其原型链<br><code>Object.getOwnPropertyDescriptor()</code>：获得obj自身属性的描述，也可以用来判断是否枚举。与<code>propertyIsEnumeable()</code>的区别是后者可以判断原型链上的属性。<br><a href="https://www.zhihu.com/question/21907133" target="_blank" rel="external">https://www.zhihu.com/question/21907133</a></p><p><code>Object.keys()</code>只返回对象自身可枚举的属性。<br><code>For...in</code>返回对象所有可枚举的属性，包括原型链继承得到的</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// underscore的核心函数，返回一个wrapped属性为obj的实例对象。&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; _ = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 若obj已经是_的一个实例，就直接返回&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 若不是通过new调用的函数，就返回一个通过new创建的obj实例&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; _)) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; _(obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 通过new创建才会触发这一步，将obj赋给实例对象的wrapped属性&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.wrapped = obj;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个函数创建一个包含有&lt;code&gt;wrapped: obj&lt;/code&gt;属性的对象&lt;/p&gt;
    
    </summary>
    
    
      <category term="underscore javascript" scheme="http://yoursite.com/tags/underscore-javascript/"/>
    
  </entry>
  
  <entry>
    <title>记录hexo搭建博客过程中遇到的问题</title>
    <link href="http://yoursite.com/2017/04/13/2017-04-13/"/>
    <id>http://yoursite.com/2017/04/13/2017-04-13/</id>
    <published>2017-04-12T16:00:00.000Z</published>
    <updated>2017-10-22T08:52:01.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-bash-command-not-found"><a href="#1-bash-command-not-found" class="headerlink" title="1. bash: command not found"></a>1. bash: command not found</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ npm i hexo-cli -g</div><div class="line">$ ...</div><div class="line">$ hexo init</div><div class="line">bash: <span class="built_in">command</span> not found</div></pre></td></tr></table></figure><a id="more"></a><p><a href="https://github.com/hexojs/hexo/issues/206" target="_blank" rel="external">这个issue</a>中有提到，只要删除npm的根文件夹重新安装就可以了。</p><p>正常来说这个方法是可以解决问题的，但是使用<code>npm root</code>之后发现，我的npm文件夹不知道为什么并没有在正常的<code>%AppData%/Roaming/npm</code>下，而是在一个诡异的位置<code>/Program Files(x86)/nodist/bin/npm</code>里面。</p><p>以前虽然安装过nodist，但是很久以前已经卸载掉了，这个nodist目录下只有一个bin，没有其他文件。</p><p>我尝试删除这个nodist文件夹重新使用npm安装，结果发现npm会自动创建这个文件夹。</p><p>然后我就猜测可能是npm的默认安装路径被改变了，查了一下，发现果然如此。Nodist安装的时候改变了npm的prefix，卸载的时候却没有给重置回去。<br>需要手动设置<code>npm config delete prefix</code>，删除干净npm重新安装</p><h3 id="2-ERROR-Deployer-not-found-github"><a href="#2-ERROR-Deployer-not-found-github" class="headerlink" title="2. ERROR Deployer not found: github"></a>2. ERROR Deployer not found: github</h3><p>执行hexo deploy来自动部署到github时，报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR Deployer not found: github</div></pre></td></tr></table></figure></p><p>文档说3.0之后版本的hexo中，deploy的type应该设置为<code>type: git</code>而不是<code>type: github</code>，但是改了之后却并没有效果</p><p>又查了一下以后，了解到需要安装一个额外的插件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer --save</div></pre></td></tr></table></figure></p><p>这次可以正常部署了</p><p>详情见<a href="https://github.com/hexojs/hexo/issues/1040" target="_blank" rel="external">这个issue</a></p><h3 id="3-图片问题"><a href="#3-图片问题" class="headerlink" title="3. 图片问题"></a>3. 图片问题</h3><p>图片上传显然不能按照md编辑器里面的相对路径来导入<br>hexo的官方文档中有提到一个叫文章资源文件夹的东西</p><blockquote><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文    章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 设为 true 来打开。<br>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code>命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p></blockquote><p>这样就可以不用自己手动指定assets，设置过后只需要把资源放到对应文章的文件夹中，然后直接引用就可以了。</p><p>比如说创建一个新文章test，hexo会自动在_post路径下创建test.md和test目录，只需要把图片放到test目录下，随后在md中使用<code>(img.png)</code>来作为图片的路径。</p><h3 id="4-自定义页面"><a href="#4-自定义页面" class="headerlink" title="4. 自定义页面"></a>4. 自定义页面</h3><p>theme/source中的文件在生成的时候会被原封不动的拷贝到public中，因此可以通过这一点来实现自定义的页面</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-bash-command-not-found&quot;&gt;&lt;a href=&quot;#1-bash-command-not-found&quot; class=&quot;headerlink&quot; title=&quot;1. bash: command not found&quot;&gt;&lt;/a&gt;1. bash: command not found&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ npm i hexo-cli -g&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ hexo init&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;bash: &lt;span class=&quot;built_in&quot;&gt;command&lt;/span&gt; not found&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
